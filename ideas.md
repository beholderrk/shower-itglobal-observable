План:
* Проблема с которой я столкнулся
* Велосипедостроение
* Как написано на официальном сайте - это комбинация лучших идей взятых из паттернов Наблюдатель, Итератор и функционального программирования. Т.е. его можно рассматривать как отдельный шаблон проектирования.
* Что взяли из шаблона наблюдатель
* Что взяли из шаблона итератор
* Что взяли из ФП
* Табличка в которой показано место Observable
* 

Что отметить:
* ReactiveX абстрагирует программистов от задач распараллеливания, синхронизации и concurrency. (Насколько это верно?)
* Меняет мышление и взрывает мозг


# Текст
1. Для начала расскажу историю о задачах и проблемах с которыми пришлось столкнуться. Все вы знаете наверное такой проект как CREX. Для передачи данных мы там используем websocket. Когда наши компоненты появляются на странице (например стакан) они начинают запрашивать данные для себя через websocket. Но вот проблема, компоненты могут появиться раньше чем установится websocket соединение c сервером. В наших реалиях установка соединения может происходить очень долго, до 5 секунд (по непонятным пока причинам), **next** и хотелось бы в это время загрузить javascript файлы что-то отрисовать. Ну так вот, задача 1, компоненты появляются, и надо сделать так чтобы их запросы не улетали в пустоту, а дождались соединения и затолкались в него. **next** Что делать если соединение оборвалось? Можно также собирать запросы и заталкивать их когда оно появится. **next** Еще есть момент, компонентов на странице очень много, и запросов на сервер они делают очень много, если кол-во запросов упирается в лимиты сервер начинает слать ошибки с информацией когда можно сделать повтор, и надо делать эти повторы через указанное время. **next** В нашем вебсокете помимо сообщений типа запрос ответ, есть еще потоки обновлений, например параметры инструмента постоянно обновляются, стакан, графики, все эти компоненты слушают разные потоки обновлений. При этом 1 поток обновлений могут слушать несколько компонентов сразу, и хорошо бы сделать так чтобы поток обновлений открывался как только появляется первый потребитель, и закрывался как только потребителей больше нет.
1. Первое решение было основано на машине состояний, и на обработчиках которые подписывались на смену этих состояний. Сначала казалось что все зашибись, но по мере накопления новых задач и решения ранее сказанных проблем код стал сильно усложняться, в какой-то момент мне уже самому стало тяжеловато его понимать, не говоря уже о других. **next** Вот пример описания машины состояний для менеджера авторизации.
1. Что же такое ReactiveX. Как написано на официальном сайте - это комбинация лучших идей взятых из паттернов Наблюдатель, Итератор и функционального программирования. Т.е. его можно рассматривать как отдельный шаблон проектирования. И как мы увидим дальше этот шаблон имеет массу реализаций на всевозможных языках.
1. Для тех кто не знает расскажу, а для тех кто знает напомню, что такое паттерн Observer. Это в общем когда у нас есть объект паблишер (или издатель по русски) и объекты подпискичи. Подписчики подписываются на издателя, это значит что издатель просто складывает объект подписчика себе в массив, т.е. он знает всех своих подписчиков, и когда происходит какое-либо событие, например новая серия "Игры престолов", он парралельно или последовательно оповещает всех подписчиков об этом. 
2. Что взято из паррена Iterator.




