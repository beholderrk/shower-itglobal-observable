План:
* Проблема с которой я столкнулся
* Велосипедостроение
* Как написано на официальном сайте - это комбинация лучших идей взятых из паттернов Наблюдатель, Итератор и функционального программирования. Т.е. его можно рассматривать как отдельный шаблон проектирования.
* Что взяли из шаблона наблюдатель
* Что взяли из шаблона итератор
* Что взяли из ФП
* Табличка в которой показано место Observable
* Сказать о недостатках 

    Высокий порог входа: легко выстрелить себе в ногу, ошибиться и долго не понимать в чем проблема из-за того что не до конца разобрался в инструменте. Мозг ломается даже у любителей функционального программированияя. "Открывается совершенно другой мир"
    
    Производительность : Позволяет не думать о потоках в многопоточных окружениях (С#,.Net, Java), сам по себе все это сделает за тебя, Ты можешь распараллелить обработку особо не задумываясь об этих вещах. Подход ReacticeX врядли будет узким местом в приложении. Все реализации очень хорошо оттестированы, хорошо работают. Больше минусов я не вижу.

Что отметить:
* ReactiveX абстрагирует программистов от задач распараллеливания, синхронизации и concurrency. (Не знаю насколько это верно? Не удалось пощупать)
* Меняет мышление и взрывает мозг


# Текст
1. Всем приверт. Доклад мой про такуцю штуку под общим названием ReactiveX. В общем цель этого доклада просто дать общее представление о том что это такое, т.к. тема на самом деле необъятная. Я проходил курс на udemy на 5 часов и там в общем-то только основы.
1. Для начала расскажу историю о задачах и проблемах с которыми пришлось столкнуться. Все вы знаете наверное такой проект как CREX. Для передачи данных мы там используем websocket. Когда наши компоненты появляются на странице (например стакан) они начинают запрашивать данные для себя через websocket. Но вот проблема, компоненты могут появиться раньше чем установится websocket соединение c сервером. В наших реалиях установка соединения может происходить очень долго, до 5 секунд (по непонятным пока причинам), **next** и хотелось бы в это время загрузить javascript файлы что-то отрисовать. Ну так вот, задача 1, компоненты появляются, и надо сделать так чтобы их запросы не улетали в пустоту, а дождались соединения и затолкались в него. **next** Что делать если соединение оборвалось? Можно также собирать запросы и заталкивать их когда оно появится. **next** Еще есть момент, компонентов на странице очень много, и запросов на сервер они делают очень много, если кол-во запросов упирается в лимиты сервер начинает слать ошибки с информацией когда можно сделать повтор, и надо делать эти повторы через указанное время. **next** В нашем вебсокете помимо сообщений типа запрос ответ, есть еще потоки обновлений, например параметры инструмента постоянно обновляются, стакан, графики, все эти компоненты слушают разные потоки обновлений. При этом 1 поток обновлений могут слушать несколько компонентов сразу, и хорошо бы сделать так чтобы поток обновлений открывался как только появляется первый потребитель, и закрывался как только потребителей больше нет.
1. Первое решение было основано на машине состояний, и на обработчиках которые подписывались на смену этих состояний. Сначала казалось что все зашибись, но по мере накопления новых задач и решения ранее сказанных проблем код стал сильно усложняться, в какой-то момент мне уже самому стало тяжеловато его понимать, не говоря уже о других. **next** Вот пример описания машины состояний для менеджера авторизации. Мне постоянно приходилось самому реализовывать код в стиле паттерна Observer (далее поясню что это), код все время усложнялся, и в общем было ощущение что я занимаюсь велосипедостроением. Все это так или иначе заставляло смотреть в сторону ReactiveX.
1. Что же такое ReactiveX. Ранее я слышал об этом как о какой-то библиотеке которая как-то круто может работать с потоками событий, и типа лучше чем промисы. Как написано на официальном сайте - это комбинация лучших идей взятых из паттернов Наблюдатель, Итератор и функционального программирования. Т.е. его можно рассматривать как отдельный шаблон проектирования. И как мы увидим дальше этот шаблон имеет массу реализаций на всевозможных языках.
1. Вообще место observable среди других идей можно охарактеризовать этой табличкой. Нужно ли пояснить что такое синхронно и асинхронно? Ок на пальцах. Допустим Наташа что-то набирает на клавиатуре, подходит Руслан и говорит "Наташ", и Наташа тут же прерывает все свои дела и смотрит на него и говорит "Да, я тебя очень внимательно слушаю". Это синхронное взаимодействие. Или например подходит такой Руслан и говорит "Наташ", а наташа печатает, а руслан Ждет, и наконец она заканчивает печатать и говорит "Отвали". Это асинхронное взаимодействие. Вот у нас есть обычное единоразовое синхронное получение набора данных. Вот у нас есть синхронное многоразовое получение набора данных - это Итератор.
Вот у нас есть асинхронное единоразовое получение данных - это промисы в js, таски в C#, фьючерсы в Java. B вот оно место observable - Асинхронное многоразовое получение набора данных.
1. Для тех кто не знает расскажу, а для тех кто знает напомню, что такое паттерн Observer. Это в общем когда у нас есть объект паблишер (или издатель по русски) и объекты подписчики. Подписчики подписываются на издателя, это значит что издатель просто складывает объект подписчика себе в массив, т.е. он знает всех своих подписчиков, и когда происходит какое-либо событие, например новая серия "Игры престолов", он парралельно или последовательно оповещает всех подписчиков об этом. 
1. Паттерн итератор. Это такой паттерн который позволяет последовательно обходить структуры данных, не раскрывая их внутреннего представления. Ну мы все знакомы с тем что итераторам которыми мы пользуемся каждый день все равно что там лежит внутри этой структуры. Итератор регламентирует только каким образом он будет обходить конкретную структуру данных. У связанного списка один итератор, у массива другой, у графа 3-й. На слайде показан итератор который построчно читает файл.
1. Что взято из паттерна Iterator. Можно отноститься к Observable как к толкающему аналогу Iterator. Когда последний как бы вытаскивающий. Есть 2 важные вещи которые взяты из паттерна Итератор 1, и которых нет в классическом паттерне Observer от банды 4-х **next** 1 - возможность источника сообщить потребителям что данных больше нет **next** 2 - возможность источника сообщить потребителям об ошибке. В общем то вся разница между Итератором и Observable в направлении данных. **next** И это очень важно так как все операции которые можно делать на Итератором можно делать и над Observable.
1. Сверху вы видите пример использования итератора, т.е. take skip map forEach это ф-ии перебора на основе итератора. Ниже приведен пример observable. В этом примере мы получаем сообщения из сети асинхронно. И можно заметить некоторое сходство.
1. В общем то все могущество ReactiveX заключено в его операторах. 
1. Посмотрим на небольшой пример. Допустим у нас на странице есть поиск по пользователям. Т.е. когда мы что-то вводим в текстовое поле идут запросы на сервер и мы видим найденных пользователей. **next** Ф-я fromEvent создает обзервбл для событий change в поле ввода. Т.е. каждый раз когда мы что-то будем вводить в поле через наш обзервбл searchText будут пролетать объекты событий. Но чтобы отправить запрос на сервер нас не интересует весь объект события, нас интересует только введеное значение. **next** Поэтому мы начинаем применять цепочку трансформаций над нашим потоком событий, оператор map поможет нам извлечь текущее значение. Если подумать то поидее нам не нужно отправлять запрос на каждый введенный символ, мы может делать это переодически скажем раз 400 мс, с этим нам поможет **next** оператор debounceTime. Т.е. пользователь что-то постоянно вводит, но мы подождем и зафиксируем значение только через 400 мс. Далее мы возможно не хотели бы повторять запросы с одинаковыми значениями, ну то есть пользователь вводил что-то запрос отправился потом еще набрал а потом сразу стер до предыдущего состояния, и отправлися тот же самый запрос и теже самы результаты показались поэтому используем **next** distinctUntilChanged. Теперь мы готовы собственно сделать запрос, но еще хотелось бы запросы делать так что если они начинают накладываться один на другой чтобы все предыдущие отменялись. **next** ок нет проблем оператор switchmap нам с этим поможет. **next** Где-то в приложении подписываемся на этот поток, вводим значения
1. Вот так примерно это будет выглядеть во вкладке network.
1. Как rxjs мне помог. У меня была задача связанная с буферизацией сообщений которые отправляются в сокет когда сокет еще не готов. Ну вот в rx есть подходящий оператор для этих целей. Сверху наши сообщения от компонентов, здесь обсервбл который сигнализирует о том что надо открыть буфер, и есть обсервер который сигнализиует что буферизацию нужно отменить.
1. Т.е. это реальное применение, вот у нас есть источник сообщений от компонентов, наш буфер начинасит собирать сообщения когда сокет не подключен, и освобождает буфер когда сокет включился.
1. Еще одна проблема это повторы, в rx все продуманно по поводу повторов. При превышении лимита сообщений наш сервер возвращает ошибку об этом, мы ловим ее оператором retryWhen и отправка происходит повторно через указанное в ошибке время.
1. При необходимости можно реализовать свои оператор, например я сделал такой оператор который подсчитывает количество потребителей подписавшихся на поток обновлений, если это количество стало 0, то поток с сокете закрывается, если стало 1 то поток открывается.
1. Минусы которые я вижу. **next** Высокий порог входа: большое количество операторов Мозг ломается даже у любителей функционального программирования. "Открывается совершенно другой мир"   **next** Легко выстрелить себе в ногу, ошибиться и долго не понимать в чем проблема из-за того что не до конца разобрался в инструменте. 




