План:
* Проблема с которой я столкнулся
* Велосипедостроение
* Как написано на официальном сайте - это комбинация лучших идей взятых из паттернов Наблюдатель, Итератор и функционального программирования. Т.е. его можно рассматривать как отдельный шаблон проектирования.
* Что взяли из шаблона наблюдатель
* Что взяли из шаблона итератор
* Что взяли из ФП
* Табличка в которой показано место Observable
* Сказать о недостатках 

    Высокий порог входа: легко выстрелить себе в ногу, ошибиться и долго не понимать в чем проблема из-за того что не до конца разобрался в инструменте. Мозг ломается даже у любителей функционального программированияя. "Открывается совершенно другой мир"
    
    Производительность : Позволяет не думать о потоках в многопоточных окружениях (С#,.Net, Java), сам по себе все это сделает за тебя, Ты можешь распараллелить обработку особо не задумываясь об этих вещах. Подход ReacticeX врядли будет узким местом в приложении. Все реализации очень хорошо оттестированы, хорошо работают. Больше минусов я не вижу.

Что отметить:
* ReactiveX абстрагирует программистов от задач распараллеливания, синхронизации и concurrency. (Не знаю насколько это верно? Не удалось пощупать)
* Меняет мышление и взрывает мозг


# Текст
1. Для начала расскажу историю о задачах и проблемах с которыми пришлось столкнуться. Все вы знаете наверное такой проект как CREX. Для передачи данных мы там используем websocket. Когда наши компоненты появляются на странице (например стакан) они начинают запрашивать данные для себя через websocket. Но вот проблема, компоненты могут появиться раньше чем установится websocket соединение c сервером. В наших реалиях установка соединения может происходить очень долго, до 5 секунд (по непонятным пока причинам), **next** и хотелось бы в это время загрузить javascript файлы что-то отрисовать. Ну так вот, задача 1, компоненты появляются, и надо сделать так чтобы их запросы не улетали в пустоту, а дождались соединения и затолкались в него. **next** Что делать если соединение оборвалось? Можно также собирать запросы и заталкивать их когда оно появится. **next** Еще есть момент, компонентов на странице очень много, и запросов на сервер они делают очень много, если кол-во запросов упирается в лимиты сервер начинает слать ошибки с информацией когда можно сделать повтор, и надо делать эти повторы через указанное время. **next** В нашем вебсокете помимо сообщений типа запрос ответ, есть еще потоки обновлений, например параметры инструмента постоянно обновляются, стакан, графики, все эти компоненты слушают разные потоки обновлений. При этом 1 поток обновлений могут слушать несколько компонентов сразу, и хорошо бы сделать так чтобы поток обновлений открывался как только появляется первый потребитель, и закрывался как только потребителей больше нет.
1. Первое решение было основано на машине состояний, и на обработчиках которые подписывались на смену этих состояний. Сначала казалось что все зашибись, но по мере накопления новых задач и решения ранее сказанных проблем код стал сильно усложняться, в какой-то момент мне уже самому стало тяжеловато его понимать, не говоря уже о других. **next** Вот пример описания машины состояний для менеджера авторизации. Мне постоянно приходилось самому реализовывать код в стиле паттерна Observer (далее поясню что это), код все время усложнялся, и в общем было ощущение что я занимаюсь велосипедостроением. Все это так или иначе заставляло смотреть в сторону ReactiveX.
1. Что же такое ReactiveX. Ранее я слышал об этом как о какой-то библиотеке которая как-то круто может работать с потоками событий, и типа лучше чем промисы. Как написано на официальном сайте - это комбинация лучших идей взятых из паттернов Наблюдатель, Итератор и функционального программирования. Т.е. его можно рассматривать как отдельный шаблон проектирования. И как мы увидим дальше этот шаблон имеет массу реализаций на всевозможных языках.
1. Для тех кто не знает расскажу, а для тех кто знает напомню, что такое паттерн Observer. Это в общем когда у нас есть объект паблишер (или издатель по русски) и объекты подпискичи. Подписчики подписываются на издателя, это значит что издатель просто складывает объект подписчика себе в массив, т.е. он знает всех своих подписчиков, и когда происходит какое-либо событие, например новая серия "Игры престолов", он парралельно или последовательно оповещает всех подписчиков об этом. 
1. Что взято из паттерна Iterator. Можно отноститься к Observable как к толкающему аналогу Iterator. Когда последний как бы вытаскивающий. Сверху вы видите пример использования итератора, т.е. take skip map forEach это ф-ии перебора на основе итератора. Ниже приведен пример observable. В этом примере мы получаем сообщения из сети асинхронно. И можно заметить некоторое сходство.




